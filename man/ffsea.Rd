% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ffsea-base.R
\name{ffsea}
\alias{ffsea}
\alias{gsea}
\alias{GSEA}
\alias{fsea}
\alias{FSEA}
\alias{result.FacileFseaAnalysisResult}
\title{Performs Feature (Gene) Set Enrichment Analyses}
\usage{
ffsea(x, fsets, methods = NULL, ..., metadata = metadata(x))

\method{result}{FacileFseaAnalysisResult}(x, name = "object", ...)
}
\arguments{
\item{x}{A \code{FacileAnalysisResult} object, or a data.frame with feature-level
statistics, minimally with a \code{"feature_id"} column as well as one or more
\code{numeric} columns to rank features on.}

\item{fsets}{The feature sets (likely genesets) to use for testing. This
object will be passed through the \code{\link[sparrow:GeneSetDb-class]{sparrow::GeneSetDb()}} constructor to
create a \code{GeneSetDb} object that will be used for testing.}

\item{methods}{A character vector of GSEA methods to use on \code{x}. Chose any
of the \code{method} names listed by running \code{ffsea_methods(x)}. If \code{NULL}
(default), the first method from  \code{ffsea_methods(x)} will be selected.}
}
\value{
A FacileFseaAnalysisResult object, which includes a \code{SparrowResult}
object as it's \code{result()}. The geneset level statistics for each of the
methods that were run are available via \code{tidy(ffsea.res, "<method_name>")}.
}
\description{
Currently we support running a number of feature (gene) set enrichment
analyses downstream of a \emph{some other} \code{FacileAnalysisResult} (ie.,
\verb{[fdge() | fpca()] |> ffsea()}), or over an arbitrary data.frame of
feature-level statistics.

Please refer to the examples here, as well as theh \emph{"Feature Set Analysis"}
section of the vignette for more information.
}
\details{
:
When running \code{ffsea} over a \code{FacileAnalysisResult}, the types of methods
that can be run, and their configuration are preconfigured with reaonable
defaults.

When providing a generic \code{data.frame} of feature-level statistics to run
enrichment tests over, the user has to specificy a few more parmaters.
If running a "pre-ranked" test, (\code{method \%in\% c("cameraPR", "fgsea")}) the
name of a numeric column in \code{x} must be specified to rank the features by,
and the order by which to do that using the \code{rank_by} and \code{rank_order}
arguments, respectively.

If running an overrepresentation analysis-style test (\code{method = "ora"}),
the user must specifcy the name of a logical column that indicates
(when \code{TRUE}) that a feature should be included for enrichment testing. The
user can optionally specify a \code{group_by} column, like \code{"direction"}, that
will be used to split the selected features into groups to perform more
specific enrichmen tests. This allows you enrichment tests to be run
separately for \code{"up"} and \code{"down"} regulated genes separately, for example.

Lastly, the user can provide the name of another numeric column in \code{x} with
\code{biased_by} which can be used to account for bias in the enrichment tests,
such as gene length, GC content, etc.

Gene sets must be supplied as a \code{\link[sparrow:GeneSetDb-class]{sparrow::GeneSetDb()}} object.
}
\section{GSEA Methods}{

Currently, only the following GSEA methods are supported:
\itemize{
\item \code{"cameraPR"}: Delegates to \code{\link[limma:camera]{limma::cameraPR()}} to perform a competitive
gene set test based on feature ranks imposed downstream of an analysis
\item \code{"fgsea"}: Delegates to \code{\link[fgsea:fgsea]{fgsea::fgsea()}} to perform another version of
a competitive gene set test based on ranks.
\item \code{"ora"}: Performs an overrepresentation analysis test. The user
must specify the name of \code{logical} column (\code{select_by}) from the input
which is used to indicate the features that are selected for enrichment
analysis. The user can optionally provide the name of a \code{numeric} column
(\code{biased_by}) and \code{character} column (\code{group_by}), which will adjust the
enrichment test for a covariate that may induce a bias in the DGE results,
and also run follow up enrichment tests based by differnt groups of
features (\code{group_by}). For example, the result table might have a
\code{"direction"} column, which specifies the direciton of differential
expression (\code{"up"}, or \code{"down"}). In this case, enrichment tests will be
run over \emph{all} features together, and then independantly for the ones that
are \code{"up"}, and \code{"down"}.
}
}

\section{GSEA Statistics}{

The geneset level statistics can be extracted from the
\code{FacileFseaAnalysisResult} on a per-method basis usig the \code{tidy()} function.
For instance, if \code{ffsea()} was called with
\verb{fres <- ffsea(..., methods = c("cameraPR", "ora")}, the \code{"cameraPR"}
results can be extracted via \code{tidy(fres, "cameraPR")}
}

\section{Development Notes}{

This functionality delegates to \code{\link[sparrow:seas]{sparrow::seas()}} to do all of the work. The
sparrow::seas interface is undergoing a bit of refactoring in order to better
support a table of feature statistcs as input (for preranked and enrichment
tests), so the \code{"methods"} supported via \code{ffsea()} are limited to a subset
of the ones wrapped by \code{\link[sparrow:seas]{sparrow::seas()}}, as enumerated below.
}

\section{Accessing Results}{

We are in a bit of a schizophrenic state right now, where \code{tidy()} is
being the de-facto way to answer "tidy" like results (instead of result()).

This is not to say that \code{result()} can't also return something that's
"tidy", but in this case, result(ffsea.result) will return the
SparrowResult object itself, and \code{tidy(ffsea.result)} will dispatch
to \code{\link[sparrow:results]{sparrow::result()}} to fetch the gsea statistcs for the method
requested.

\if{html}{\out{<div class="sourceCode">}}\preformatted{mgres <- result(ffsea.res) # returns the SparrowResult object
camera.stats <- tidy(ffsea.res, name = "cameraPR")
}\if{html}{\out{</div>}}
}

\examples{
gdb <- sparrow::exampleGeneSetDb()
efds <- FacileData::exampleFacileDataSet()

# GSEA from t-test result ---------------------------------------------------
ttest.res <- efds |>
  FacileData::filter_samples(indication == "CRC") |>
  flm_def(covariate = "sample_type", numer = "tumor", denom = "normal",
          batch = "sex") |>
  fdge(method = "voom")

ttest.gsea <- ffsea(ttest.res, gdb, methods = c("cameraPR", "ora"),
                    biased_by = "effective_length")
if (interactive()) {
  viz(ttest.gsea, type = "density", name = "HALLMARK_HEDGEHOG_SIGNALING")
  viz(ttest.gsea, type = "gsea", name = "HALLMARK_HEDGEHOG_SIGNALING")

  shine(ttest.igsea)
  ttest.igsea <- ffseaGadget(ttest.res, gdb)
}

camera.stats <- tidy(ttest.gsea, "cameraPR")
ora.stats <- tidy(ttest.gsea, "ora")

# GSEA from ANOVA result ----------------------------------------------------
stage.anova <- efds |>
  FacileData::filter_samples(indication == "BLCA") |>
  flm_def(covariate = "stage", batch = "sex") |>
  fdge(method = "voom")
anova.gsea <- ffsea(stage.anova, gdb)
if (interactive()) {
 # TODO: shine(anova.gsea) doesn't work
 shine(anova.gsea)
 # We can generate the same GSEA result like so
 anova.gsea2 <- ffseaGadget(stage.anova, gdb = gdb)
}
# GSEA over loadings on a Principal Component -------------------------------
pca.crc <- efds |>
  FacileData::filter_samples(indication == "CRC") |>
  fpca()
pca1.gsea <- ffsea(pca.crc, gdb, dim = 1)
}
\seealso{
https://github.com/lianos/sparrow
}
