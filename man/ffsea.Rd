% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ffsea.R
\name{ffsea}
\alias{ffsea}
\alias{gsea}
\alias{GSEA}
\alias{fsea}
\alias{FSEA}
\alias{result.FacileFseaAnalysisResult}
\title{Performs Feature (Gene) Set Enrichment Analyses}
\usage{
ffsea(x, gdb, methods = "cameraPR", ...)

\method{result}{FacileFseaAnalysisResult}(x, name = "object", ...)
}
\arguments{
\item{x}{A \code{FacileAnalysisResult} object, or a data.frame with feature-level
statistics, minimally with a \code{"feature_id"} column as well as one or more
\code{numeric} columns to rank features on.}

\item{gdb}{A \code{\link[multiGSEA:GeneSetDb-class]{multiGSEA::GeneSetDb()}} object}

\item{methods}{the GSEA methods to use on \code{x}.}
}
\value{
A FacileFseaAnalysisResult object, which includes a MultiGSEAResult
object as it's \code{result()}. The geneset level statistics for each of the
methods that were run are available via \code{tidy(ffsea.res, "<method_name>")}.
}
\description{
Currently we support running a number of feature (gene) set enrichment
analyses downstream of a \emph{some other} \code{FacileAnalysisResult} (ie.,
\verb{[fdge() | fpca()] \%>\% ffsea()}), or over an arbitrary data.frame of
feature-level statistics.

Please refer to the examples here, as well as theh \emph{"Feature Set Analysis"}
section of the vignette for more information.
}
\details{
:
When running \code{ffsea} over a \code{FacileAnalysisResult}, the types of methods
that can be run, and their configuration are preconfigured with reaonable
defaults.

When providing a generic \code{data.frame} of feature-level statistics to run
enrichment tests over, the user has to specificy a few more parmaters.
If running a "pre-ranked" test, (\code{method \%in\% c("cameraPR", "fgsea")}) the
name of a numeric column in \code{x} must be specified to rank the features by,
and the order by which to do that using the \code{rank_by} and \code{rank_order}
arguments, respectively.

If running an overrepresentation analysis-style test (\code{method = "ora"}),
the user must specifcy the name of a logical column that indicates
(when \code{TRUE}) that a feature should be included for enrichment testing. The
user can optionally specify a \code{group_by} column, like \code{"direction"}, that
will be used to split the selected features into groups to perform more
specific enrichmen tests. This allows you enrichment tests to be run
separately for \code{"up"} and \code{"down"} regulated genes separately, for example.

Lastly, the user can provide the name of another numeric column in \code{x} with
\code{biased_by} which can be used to account for bias in the enrichment tests,
such as gene length, GC content, etc.

Gene sets must be supplied as a \code{\link[multiGSEA:GeneSetDb-class]{multiGSEA::GeneSetDb()}} object.
}
\section{GSEA Methods}{

Currently, only the following GSEA methods are supported:
\itemize{
\item \code{"cameraPR"}: Delegates to \code{\link[limma:camera]{limma::cameraPR()}} to perform a competitive
gene set test based on feature ranks imposed downstream of an analysis
\item \code{"fgsea"}: Delegates to \code{\link[fgsea:fgsea]{fgsea::fgsea()}} to perform another version of
a competitive gene set test based on ranks.
\item \code{"ora"}: Performs an overrepresentation analysis test. The user
must specify the name of \code{logical} column (\code{select_by}) from the input
which is used to indicate the features that are selected for enrichment
analysis. The user can optionally provide the name of a \code{numeric} column
(\code{biased_by}) and \code{character} column (\code{group_by}), which will adjust the
enrichment test for a covariate that may induce a bias in the DGE results,
and also run follow up enrichment tests based by differnt groups of
features (\code{group_by}). For example, the result table might have a
\code{"direction"} column, which specifies the direciton of differential
expression (\code{"up"}, or \code{"down"}). In this case, enrichment tests will be
run over \emph{all} features together, and then independantly for the ones that
are \code{"up"}, and \code{"down"}.
}
}

\section{GSEA Statistics}{

The geneset level statistics can be extracted from the
\code{FacileFseaAnalysisResult} on a per-method basis usig the \code{tidy()} function.
For instance, if \code{ffsea()} was called with
\verb{fres <- ffsea(..., methods = c("cameraPR", "ora")}, the \code{"cameraPR"}
results can be extracted via \code{tidy(fres, "cameraPR")}
}

\section{Development Notes}{

This functionality delegates to multiGSEA to do all of the work. The
multiGSEA interface is undergoing a bit of refactoring in order to better
support a table of feature statistcs as input (for preranked and enrichment
tests), so the \code{"methods"} supported via \code{ffsea()} are limited to a subset
of the ones wrapped by multiGSEA, as enumerated below.
}

\section{Accessing Results}{

We are in a bit of a schizophrenic state right now, where \code{tidy()} is
being the de-facto way to answer "tidy" like results (instead of result()).

This is not to say that \code{result()} can't also return something that's
"tidy", but in this case, result(ffsea.result) will return the
MultiGSEAResult object itself, and \code{tidy(ffsea.result)} will dispatch
to \code{\link[multiGSEA:results]{multiGSEA::result()}} to fetch the gsea statistcs for the method
requested.\preformatted{mgres <- result(ffsea.res) # return the MultiGSEAResult object
camera.stats <- tidy(ffsea.res, name = "cameraPR")
}
}

\examples{
gdb <- multiGSEA::getMSigGeneSetDb("h", "human", id.type = "entrez")
efds <- FacileData::exampleFacileDataSet()

# GSEA from t-test result ---------------------------------------------------
ttest.res <- efds \%>\%
  FacileData::filter_samples(indication == "CRC") \%>\%
  flm_def(covariate = "sample_type", numer = "tumor", denom = "normal",
          batch = "sex") \%>\%
  fdge(method = "voom")

ttest.gsea <- ffsea(ttest.res, gdb, methods = c("cameraPR", "ora"),
                    biased_by = "effective_length")
if (interactive()) {
  ttest.gsea <- ffseaGadget(ttest.res, gdb)
  shine(ttest.gsea)
}

camera.stats <- tidy(ttest.gsea, "cameraPR")
ora.stats <- tidy(ttest.gsea, "ora")

# GSEA from ANOVA result ----------------------------------------------------
stage.anova <- efds \%>\%
  FacileData::filter_samples(indication == "BLCA") \%>\%
  flm_def(covariate = "stage", batch = "sex") \%>\%
  fdge(method = "voom")
anova.gsea <- ffsea(stage.anova, gdb)
if (interactive()) {
 shine(anova.gsea)
 # We can generate the same GSEA result like so
 anova.gsea2 <- ffseaGadget(stage.anova, gdb = gdb)
}
# GSEA over loadings on a Principal Component -------------------------------
pca.crc <- efds \%>\%
  FacileData::filter_samples(indication == "CRC") \%>\%
  fpca()
pca1.gsea <- ffsea(pca.crc, gdb, dim = 1)
}
\seealso{
https://github.com/lianos/multiGSEA
}
